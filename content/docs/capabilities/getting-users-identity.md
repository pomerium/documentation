---
# cSpell:ignore ecparam genkey noout pubout secp256r1 QCN7adG2AmIK3UdHJvVJkldsUc6XeBRz83Z4rXX8Va4 ary66nrvA55TpaiWADq8b3O1CYIbvjqIHpXCY

title: JWT Authentication
description: Learn how Pomerium supports single sign-on (SSO) and identity verification with JWT authentication and signed HTTP headers.
sidebar_label: JWT Authentication
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import GoApp from '../../examples/go-sdk/go-app.md';
import ReactApp from '../../examples/js-sdk/react-app.md';

# JWT Authentication

This document describes how Pomerium supports JWT authentication in upstream services with JSON web tokens (JWTs).

<iframe
  width="100%"
  height="415"
  src="https://www.youtube.com/embed/mc9USXDiCmk"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen></iframe>

## Overview

JWTs provide a secure and efficient means to authenticate and authorize users before they can access upstream services behind Pomerium. By default, Pomerium secures these connections over TLS, but you can also configure Pomerium to provide an additional layer of security with **JWT authentication** at the application level. This way, even if other security checks fail, the upstream service can grant or deny access based on the authenticity of the JWT. 

## Why JWT authentication?

**Identity verification**

JWT authentication through Pomerium enables an upstream service to verify a user's identity based on claims contained in the JWT. Pomerium signs and issues a new JWT based on the ID token received from the service's configured identity provider, so the upstream service can trust that the claims were not modified in transit.

**Request verification**

Because Pomerium handles each request before forwarding it, the upstream service can verify that Pomerium processed the request.

An upstream service behind Pomerium should only accept an incoming request if it can confirm that the JWT is valid, the user's identity is authenticated, and that Pomerium processed the request.  

**Single Sign-on (SSO)**

You can configure upstream services to accept JWTs sent by Pomerium to achieve an SSO authentication flow. This capability is completely free and relatively easy to configure depending on the upstream service and your [identity provider](/docs/identity-providers).

:::info Implement SSO with Pomerium

See our [Grafana](/docs/guides/grafana) guide for a real-world example of how configuring both Pomerium and and an upstream service can provide easy SSO access for your end users.

:::

## JWT authentication flow
  
  
  ![A diagram that shows how Pomerium forwards JWTs to an upstream application](./img/jwt-authn/JWT%20Authentication.svg)

### Identity provider authentication

Pomerium requires users to authenticate against an OIDC-compliant identity provider before authorizing or denying a request to an upstream service. 

After successful authentication, Pomerium mints a new [**Pomerium JWT**](#pomerium-jwt) based on the **ID token** generated by the identity provider. (This is Pomerium's default behavior, even if you haven't configured Pomerium to support JWT authentication.)

### Signed HTTP header

Pomerium signs the Pomerium JWT with a private [signing key](/docs/reference/signing-key) on behalf of the user, and places the JWT into a special HTTP header called the `X-Pomerium-Jwt-Assertion-Header`. This signed header is included in the HTTP request that Pomerium forwards to the upstream service.

### JWT validation

The upstream service receives the `X-Pomerium-Jwt-Assertion-Header` with the encrypted JWT. To validate a JWT, the service should check the following items:

- [JWT signature](#jwt-signature)
- [Audience (`aud`) claim](#aud-claim)
- [JWT timestamps](#jwt-timestamps)

---

#### JWT signature

Validating the JWT signature requires fetching the corresponding public key from the [**JSON web key set**](https://datatracker.ietf.org/doc/html/rfc8414#section-2) (JWKS) endpoint. The JWKS endpoint is reachable from any Pomerium-managed route domain at `/.well-known/pomerium/jwks.json`. 

For example:

<Tabs>
<TabItem label="Hosted Authenticate" value="hosted-authenticate">

:::note

When using the [hosted authenticate service](/docs/capabilities/hosted-authenticate-service), Pomerium uses the route domain as the [**Authenticate Service URL**](/docs/reference/authenticate-service-url).

:::

```bash
curl https://service.corp.example.com/.well-known/pomerium/jwks.json | jq
```

</TabItem>
<TabItem label="Self-hosted Authenticate" value="self-hosted-authenticate">

```bash
curl https://<AUTHENTICATE-SERVICE-URL>/.well-known/pomerium/jwks.json | jq
```

</TabItem>
</Tabs>

A successful request returns a JSON object describing the signing key. The `kid` parameter contains the signing key ID, which is used to calculate the corresponding public key.


```json title="JWKS response"
{
  "keys": [
    {
      "use": "sig",
      "kty": "EC",
      // highlight-start
      "kid": "ccc5bc9d835ff3c8f7075ed4a7510159cf440fd7bf7b517b5caeb1fa419ee6a1",
      // highlight-end
      "crv": "P-256",
      "alg": "ES256",
      "x": "QCN7adG2AmIK3UdHJvVJkldsUc6XeBRz83Z4rXX8Va4",
      "y": "PI95b-ary66nrvA55TpaiWADq8b3O1CYIbvjqIHpXCY"
    }
  ]
}
```

#### Aud claim

The `aud` claim identifies the recipient the JWT is intended for. In the context of a service behind Pomerium, the `aud` claim should always be set as the upstream service's domain name. 

If the domain provided in the `aud` claim doesn't match the upstream service's domain name, the JWT can't be validated or trusted.

#### JWT timestamps

The `iat` claim informs you at what time the JWT was issued. The `exp` claim specifies the expiration time on or after which the JWT must be considered invalid. By default, Pomerium sets the `exp` claim to expire 5 minutes after the time it was issued.

If the JWT has expired, it is not longer valid and can't be trusted.

---

After the upstream service validates the JWT, it can accept the JWT and the request. 

## The Pomerium JWT

Pomerium generates a new **Pomerium JWT** based on the claims data contained in the original ID token. In addition to including standard claims as defined in [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1), Pomerium also injects its own claims into the Pomeruim JWT as well. (See [JWT claims data](#jwt-claims-data) below for more details.)

:::note

The original ID token sourced from an identity provider is never modified or leaked to end users or upstream services.

:::

### Pomerium JWT claims data

When Pomerium is configured for JWT authentication, the user's associated identity information will be included in the signed `X-Pomerium-Jwt-Assertion` header in each upstream request. The signed Pomerium JWT is also available at the special `/.pomerium/jwt` endpoint of any URL handled by Pomerium.

The Pomerium JWT contains at least the following claims:

| claim | description |
| :-: | --- |
| `jti` | A randomly generated UUID that represents the JWT ID. |
| `exp` | Expiration time in seconds since the UNIX epoch. Set to expire 5 minutes after `iat` time. |
| `iat` | Issued-at time in seconds since the UNIX epoch. |
| `aud` | The domain for the upstream application (for example, `httpbin.corp.example.com`). |
| `iss` | Same as the `aud` claim. |
| `sub` | The user's ID, as specified by the identity provider. |
| `email` | The user's email address. |
| `groups` | The user's group memberships (if supported for the identity provider). |
| `name` | The user's full name, as specified by the identity provider. |

:::info Validating "aud" and "iss" claims

The `aud` claim defines what application the JWT is intended for. Pomerium sets the `aud` claim to be the domain of the target upstream application.

Since v0.22, Pomerium sets the `iss` claim also to the domain of the target upstream application. (In previous versions, this was instead set to the authentication service domain.)

Upstream services should verify that these claims match the expected domain in order to prevent token reuse between different upstream services.

:::

### JWT Settings

Use these settings to configure Pomerium to forward the Pomerium JWT to upstream services:

- [Pass Identity Headers (global)](/docs/reference/pass-identity-headers)
- [Pass Identity Headers (per route)](/docs/reference/routes/pass-identity-headers-per-route)

If your identity provider provides other claims not included in the Pomerium JWT that you would like to pass to your application, you can use the [JWT Claims Headers](/docs/reference/jwt-claim-headers) option to include them in the JWT as well.

:::tip JWT Verification with Pomerium SDKs

Pomerium's **[Go and JavaScript SDKs]** provide free JWT libraries so you don't have to implement JWT verification yourself. 

See the following guides to quickly implement JWT verification with our SDKs:

- **[JS SDK]**
- **[GO SDK]**

:::

---

## JWT verification

Before trusting any user identity information in the JWT, your application should verify:

1. The JWT has a valid signature from a trusted source.
2. The JWT has not expired.
3. The JWT audience and issuer match your application's domain.

Signed headers are used to establish an extra layer of authentication. For more information on the benefits, check out our [blog post](https://www.pomerium.com/blog/signed-headers-a-safety-net-for-application-security/) on this topic!

The attestation JWT's signature can be verified using the public key retrieved from Pomerium's `/.well-known/pomerium/jwks.json` endpoint (on any route domain). For example:

```bash
curl https://your-app.corp.example.com/.well-known/pomerium/jwks.json | jq
```

```json
{
  "keys": [
    {
      "use": "sig",
      "kty": "EC",
      "kid": "ccc5bc9d835ff3c8f7075ed4a7510159cf440fd7bf7b517b5caeb1fa419ee6a1",
      "crv": "P-256",
      "alg": "ES256",
      "x": "QCN7adG2AmIK3UdHJvVJkldsUc6XeBRz83Z4rXX8Va4",
      "y": "PI95b-ary66nrvA55TpaiWADq8b3O1CYIbvjqIHpXCY"
    }
  ]
}
```

(This endpoint can also be used to integrate with other systems, such as [Istio](https://istio.io/). For example, see the Istio guide on [Authentication Policy](https://istio.io/latest/docs/reference/config/security/jwt/#JWTRule-jwks_uri), and specifically the [`jwksUri`](https://istio.io/latest/docs/reference/config/security/jwt/#JWTRule-jwks_uri) key on the `jwtRules` mapping.)

:::caution

In order to use the `/.well-known/pomerium/jwks.json` endpoint you must set either the [Signing Key] or [Signing Key File] configuration option.

:::

After verifying the JWT signature, your application should verify that JWT has not expired, by comparing the current time with the timestamps in the `exp` and `iat` claims. We recommend allowing up to 1 minute leeway in this comparison, to account for clock skew between Pomerium and your application.

And finally, your application should verify that the `aud` and `iss` claim both match the domain used to serve your application.

### Verification in a Go application

For an application written in Go, you can use the [Go SDK] to perform the necessary verification steps. For example:

<GoApp />

### Verification in a Single-Page Application

A single-page javascript application can verify the JWT using the [JavaScript SDK]. For example:

<ReactApp />

### Manual verification

Though you will likely verify signed headers programmatically in your application's middleware with a third-party JWT library, if you are new to JWT it may be helpful to show what manual verification looks like.

1. Provide Pomerium with a base64-encoded Elliptic Curve ([NIST P-256]) Private Key. In production, you'd likely want to get these from your key management service (KMS).

   ```bash
   openssl ecparam -genkey -name prime256v1 -noout -out ec_private.pem
   openssl ec -in ec_private.pem -pubout -out ec_public.pem
   # careful! this will output your private key in terminal
   cat ec_private.pem | base64
   ```

   Copy the base64 encoded value of your private key to Pomerium's environmental configuration variable `SIGNING_KEY`.

   ```bash
   SIGNING_KEY=LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JR0hBZ0VBTUJNR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEJHMHdhd0lCQVFRZzBQdk1VeVZGeWxTbGZ3eDgKSDBxMUVyOHZlOXBnY3ZzNkV6ZnR5OHlxNnFLaFJBTkNBQVM5ZC96TC9aSXd5ZGQ1RXZMb0xGMytHblVIUS9wdQpQaU45NDV1Y1RpTFRqMDhZalo3U0NJV2JHc2tiK0RIMzJ2aUc2KzRnb0FvWlFUM1R6b2kzRVl6OAotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tCg==
   ```

1. Reload Pomerium. Navigate to httpbin (by default, `https://httpbin.corp.${YOUR-DOMAIN}.com`), and log in as usual. Click **request inspection**. Select `/headers`. Click **try it out** and then **execute**. You should see something like the following.

   ![httpbin displaying jwt headers](./img/inspect-headers.png)

1. `X-Pomerium-Jwt-Assertion` is the signature value. It's less scary than it looks and basically just a compressed, json blob as described above. Navigate to [jwt.io] which provides a helpful GUI to manually verify JWT values.

1. Paste the value of `X-Pomerium-Jwt-Assertion` header token into the `Encoded` form. You should notice that the decoded values look much more familiar.

   ![httpbin displaying decoded jwt](./img/verifying-headers-1.png)

1. Finally, we want to cryptographically verify the validity of the token. To do this, we will need the signer's public key. You can simply copy and past the output of `cat ec_public.pem`.

   ![httpbin displaying verified jwt](./img/jwt-payload.png)

**Voila!** Hopefully walking through a manual verification has helped give you a better feel for how signed JWT tokens are used as a secondary validation mechanism in pomerium.

:::caution

In an actual client, you'll want to ensure that all the other claims values are valid (like expiration, issuer, audience and so on) in the context of your application. You'll also want to make sure you have a safe and reliable mechanism for distributing the public signing key to client apps (typically, a [key management service]).

:::

[go sdk]: https://github.com/pomerium/sdk-go
[jwt]: https://jwt.io/introduction/
[javascript sdk]: https://github.com/pomerium/js-sdk
[jwt library]: https://jwt.io/libraries
[jwt.io]: https://jwt.io/
[key management service]: https://en.wikipedia.org/wiki/Key_management
[nist p-256]: https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf
[pass identity headers]: /docs/reference/routes/pass-identity-headers-per-route
[signing key]: /docs/reference/signing-key
[signing key file]: /docs/reference/signing-key-file
